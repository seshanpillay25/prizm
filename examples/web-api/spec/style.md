# Style Guide - Task Management API\n\n## Overview\n\nThis document establishes coding standards, conventions, and best practices for the Task Management API project. Consistent style improves code readability, maintainability, and team collaboration.\n\n**Project:** Task Management API  \n**Language:** Node.js/TypeScript  \n**Framework:** Express.js  \n**Enforcement:** ESLint, Prettier, TypeScript compiler\n\n## General Principles\n\n### Code Quality Principles\n\n1. **Readability First:** Code should be self-documenting and easy to understand\n2. **Consistency:** Follow established patterns throughout the codebase\n3. **TypeScript:** Use TypeScript for type safety and better developer experience\n4. **Explicit over Implicit:** Be explicit about intentions and types\n5. **Fail Fast:** Validate inputs early and throw meaningful errors\n\n### API Design Principles\n\n- **RESTful Design:** Follow REST conventions for endpoint naming\n- **Consistent Responses:** Use standard response formats\n- **Proper HTTP Status Codes:** Use appropriate status codes for different scenarios\n- **Clear Error Messages:** Provide actionable error information\n\n## TypeScript Guidelines\n\n### Type Definitions\n\n**Interface Naming:**\n```typescript\n// ✅ Good - descriptive interface names\ninterface TaskCreateRequest {\n  title: string;\n  description?: string;\n  dueDate?: Date;\n  categoryId?: string;\n}\n\ninterface TaskResponse {\n  id: string;\n  title: string;\n  description: string | null;\n  status: TaskStatus;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// ❌ Bad - generic or unclear names\ninterface Task {\n  title: string;\n  // ... other properties\n}\n\ninterface Data {\n  // ... properties\n}\n```\n\n**Enum Usage:**\n```typescript\n// ✅ Good - explicit enum values\nenum TaskStatus {\n  PENDING = 'pending',\n  IN_PROGRESS = 'in-progress',\n  COMPLETED = 'completed'\n}\n\nenum HttpStatus {\n  OK = 200,\n  CREATED = 201,\n  BAD_REQUEST = 400,\n  UNAUTHORIZED = 401,\n  FORBIDDEN = 403,\n  NOT_FOUND = 404,\n  INTERNAL_SERVER_ERROR = 500\n}\n\n// ❌ Bad - relying on auto-generated values\nenum TaskStatus {\n  PENDING,\n  IN_PROGRESS,\n  COMPLETED\n}\n```\n\n**Type Guards:**\n```typescript\n// ✅ Good - type guards for runtime validation\nfunction isTaskStatus(value: string): value is TaskStatus {\n  return Object.values(TaskStatus).includes(value as TaskStatus);\n}\n\nfunction isUUID(value: string): value is string {\n  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n  return uuidRegex.test(value);\n}\n\n// Usage\nif (isTaskStatus(req.body.status)) {\n  // TypeScript knows req.body.status is TaskStatus\n  task.status = req.body.status;\n}\n```\n\n### Function Signatures\n\n**Async Function Patterns:**\n```typescript\n// ✅ Good - explicit return types and error handling\nclass TaskService {\n  async createTask(userId: string, taskData: TaskCreateRequest): Promise<TaskResponse> {\n    try {\n      const task = await this.taskRepository.create({\n        ...taskData,\n        userId,\n        status: TaskStatus.PENDING\n      });\n      \n      return this.mapToResponse(task);\n    } catch (error) {\n      throw new ServiceError('Failed to create task', error);\n    }\n  }\n  \n  async findTaskById(id: string, userId: string): Promise<TaskResponse | null> {\n    if (!isUUID(id)) {\n      throw new ValidationError('Invalid task ID format');\n    }\n    \n    const task = await this.taskRepository.findById(id, userId);\n    return task ? this.mapToResponse(task) : null;\n  }\n}\n```\n\n## Express.js Patterns\n\n### Controller Structure\n\n**Controller Organization:**\n```typescript\n// ✅ Good - clean controller with proper separation\nclass TaskController {\n  constructor(\n    private taskService: TaskService,\n    private validator: RequestValidator\n  ) {}\n  \n  createTask = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const userId = req.user!.id;\n      const taskData = this.validator.validateTaskCreate(req.body);\n      \n      const task = await this.taskService.createTask(userId, taskData);\n      \n      res.status(HttpStatus.CREATED).json({\n        success: true,\n        data: task\n      });\n    } catch (error) {\n      next(error);\n    }\n  };\n  \n  getTasks = async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const userId = req.user!.id;\n      const filters = this.validator.validateTaskFilters(req.query);\n      \n      const result = await this.taskService.getTasks(userId, filters);\n      \n      res.json({\n        success: true,\n        data: result.tasks,\n        pagination: result.pagination\n      });\n    } catch (error) {\n      next(error);\n    }\n  };\n}\n```\n\n**Route Organization:**\n```typescript\n// ✅ Good - organized route definitions\nclass TaskRoutes {\n  constructor(private taskController: TaskController) {}\n  \n  setupRoutes(): Router {\n    const router = Router();\n    \n    // Task CRUD operations\n    router.post('/', authenticate, this.taskController.createTask);\n    router.get('/', authenticate, this.taskController.getTasks);\n    router.get('/:id', authenticate, this.taskController.getTask);\n    router.put('/:id', authenticate, this.taskController.updateTask);\n    router.delete('/:id', authenticate, this.taskController.deleteTask);\n    \n    return router;\n  }\n}\n\n// Usage in app.ts\nconst taskRoutes = new TaskRoutes(taskController);\napp.use('/api/tasks', taskRoutes.setupRoutes());\n```\n\n### Middleware Patterns\n\n**Authentication Middleware:**\n```typescript\n// ✅ Good - typed middleware with proper error handling\ninterface AuthenticatedRequest extends Request {\n  user?: UserPayload;\n}\n\nconst authenticate = async (\n  req: AuthenticatedRequest,\n  res: Response,\n  next: NextFunction\n): Promise<void> => {\n  try {\n    const authHeader = req.header('Authorization');\n    \n    if (!authHeader?.startsWith('Bearer ')) {\n      throw new AuthenticationError('Access token required');\n    }\n    \n    const token = authHeader.substring(7);\n    const payload = await authService.verifyToken(token);\n    \n    req.user = payload;\n    next();\n  } catch (error) {\n    next(error);\n  }\n};\n```\n\n**Validation Middleware:**\n```typescript\n// ✅ Good - reusable validation middleware\nconst validateRequest = <T>(schema: Joi.ObjectSchema<T>) => {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    const { error, value } = schema.validate(req.body, {\n      abortEarly: false,\n      stripUnknown: true\n    });\n    \n    if (error) {\n      const validationError = new ValidationError(\n        'Request validation failed',\n        error.details.map(detail => ({\n          field: detail.path.join('.'),\n          message: detail.message\n        }))\n      );\n      \n      return next(validationError);\n    }\n    \n    req.body = value;\n    next();\n  };\n};\n```\n\n## Database Patterns\n\n### Repository Pattern\n\n**Repository Implementation:**\n```typescript\n// ✅ Good - repository with proper typing and error handling\ninterface TaskRepository {\n  create(task: TaskCreateData): Promise<TaskEntity>;\n  findById(id: string, userId: string): Promise<TaskEntity | null>;\n  findByUserId(userId: string, filters: TaskFilters): Promise<TaskEntity[]>;\n  update(id: string, updates: Partial<TaskEntity>): Promise<TaskEntity>;\n  delete(id: string, userId: string): Promise<void>;\n}\n\nclass PostgresTaskRepository implements TaskRepository {\n  constructor(private db: Pool) {}\n  \n  async create(task: TaskCreateData): Promise<TaskEntity> {\n    const query = `\n      INSERT INTO tasks (id, user_id, title, description, category_id, due_date)\n      VALUES ($1, $2, $3, $4, $5, $6)\n      RETURNING *\n    `;\n    \n    const values = [\n      generateUUID(),\n      task.userId,\n      task.title,\n      task.description || null,\n      task.categoryId || null,\n      task.dueDate || null\n    ];\n    \n    try {\n      const result = await this.db.query(query, values);\n      return this.mapToEntity(result.rows[0]);\n    } catch (error) {\n      if (error.code === '23505') { // Unique constraint violation\n        throw new ConflictError('Task already exists');\n      }\n      throw new DatabaseError('Failed to create task', error);\n    }\n  }\n  \n  async findById(id: string, userId: string): Promise<TaskEntity | null> {\n    const query = `\n      SELECT t.*, c.name as category_name\n      FROM tasks t\n      LEFT JOIN categories c ON t.category_id = c.id\n      WHERE t.id = $1 AND t.user_id = $2 AND t.deleted_at IS NULL\n    `;\n    \n    const result = await this.db.query(query, [id, userId]);\n    return result.rows[0] ? this.mapToEntity(result.rows[0]) : null;\n  }\n  \n  private mapToEntity(row: any): TaskEntity {\n    return {\n      id: row.id,\n      userId: row.user_id,\n      title: row.title,\n      description: row.description,\n      status: row.status as TaskStatus,\n      categoryId: row.category_id,\n      categoryName: row.category_name,\n      dueDate: row.due_date ? new Date(row.due_date) : null,\n      createdAt: new Date(row.created_at),\n      updatedAt: new Date(row.updated_at)\n    };\n  }\n}\n```\n\n### Query Optimization\n\n**Efficient Queries:**\n```typescript\n// ✅ Good - optimized query with proper indexing\nclass TaskRepository {\n  async findTasksWithFilters(userId: string, filters: TaskFilters): Promise<TaskEntity[]> {\n    let query = `\n      SELECT t.*, c.name as category_name,\n             array_agg(DISTINCT tag.name) FILTER (WHERE tag.name IS NOT NULL) as tags\n      FROM tasks t\n      LEFT JOIN categories c ON t.category_id = c.id\n      LEFT JOIN task_tags tt ON t.id = tt.task_id\n      LEFT JOIN tags tag ON tt.tag_id = tag.id\n      WHERE t.user_id = $1 AND t.deleted_at IS NULL\n    `;\n    \n    const params: any[] = [userId];\n    let paramIndex = 2;\n    \n    // Add filters dynamically\n    if (filters.status) {\n      query += ` AND t.status = $${paramIndex}`;\n      params.push(filters.status);\n      paramIndex++;\n    }\n    \n    if (filters.categoryId) {\n      query += ` AND t.category_id = $${paramIndex}`;\n      params.push(filters.categoryId);\n      paramIndex++;\n    }\n    \n    if (filters.search) {\n      query += ` AND (t.title ILIKE $${paramIndex} OR t.description ILIKE $${paramIndex})`;\n      params.push(`%${filters.search}%`);\n      paramIndex++;\n    }\n    \n    query += ` GROUP BY t.id, c.name`;\n    \n    // Add sorting\n    const sortField = this.validateSortField(filters.sort || 'created_at');\n    const sortOrder = filters.order === 'asc' ? 'ASC' : 'DESC';\n    query += ` ORDER BY t.${sortField} ${sortOrder}`;\n    \n    // Add pagination\n    const limit = Math.min(filters.limit || 20, 100);\n    const offset = ((filters.page || 1) - 1) * limit;\n    query += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\n    params.push(limit, offset);\n    \n    const result = await this.db.query(query, params);\n    return result.rows.map(row => this.mapToEntity(row));\n  }\n  \n  private validateSortField(field: string): string {\n    const allowedFields = ['title', 'created_at', 'updated_at', 'due_date', 'status'];\n    return allowedFields.includes(field) ? field : 'created_at';\n  }\n}\n```\n\n## Error Handling\n\n### Error Class Hierarchy\n\n**Custom Error Classes:**\n```typescript\n// ✅ Good - structured error hierarchy\nabstract class BaseError extends Error {\n  abstract statusCode: number;\n  abstract code: string;\n  \n  constructor(message: string, public originalError?: Error) {\n    super(message);\n    this.name = this.constructor.name;\n    \n    if (originalError) {\n      this.stack = originalError.stack;\n    }\n  }\n}\n\nclass ValidationError extends BaseError {\n  statusCode = HttpStatus.BAD_REQUEST;\n  code = 'VALIDATION_ERROR';\n  \n  constructor(message: string, public details?: ValidationDetail[]) {\n    super(message);\n  }\n}\n\nclass AuthenticationError extends BaseError {\n  statusCode = HttpStatus.UNAUTHORIZED;\n  code = 'AUTHENTICATION_ERROR';\n}\n\nclass AuthorizationError extends BaseError {\n  statusCode = HttpStatus.FORBIDDEN;\n  code = 'AUTHORIZATION_ERROR';\n}\n\nclass NotFoundError extends BaseError {\n  statusCode = HttpStatus.NOT_FOUND;\n  code = 'NOT_FOUND';\n}\n\nclass ConflictError extends BaseError {\n  statusCode = HttpStatus.CONFLICT;\n  code = 'CONFLICT';\n}\n\nclass DatabaseError extends BaseError {\n  statusCode = HttpStatus.INTERNAL_SERVER_ERROR;\n  code = 'DATABASE_ERROR';\n}\n```\n\n**Error Handler Middleware:**\n```typescript\n// ✅ Good - comprehensive error handling\nconst errorHandler = (\n  error: Error,\n  req: Request,\n  res: Response,\n  next: NextFunction\n): void => {\n  // Log error with context\n  logger.error(error.message, {\n    error: {\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    },\n    request: {\n      method: req.method,\n      url: req.url,\n      headers: req.headers,\n      body: req.body,\n      user: req.user?.id\n    }\n  });\n  \n  // Handle known errors\n  if (error instanceof BaseError) {\n    const response: ErrorResponse = {\n      success: false,\n      error: {\n        code: error.code,\n        message: error.message\n      }\n    };\n    \n    if (error instanceof ValidationError && error.details) {\n      response.error.details = error.details;\n    }\n    \n    return res.status(error.statusCode).json(response);\n  }\n  \n  // Handle unknown errors\n  res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({\n    success: false,\n    error: {\n      code: 'INTERNAL_ERROR',\n      message: 'An unexpected error occurred'\n    }\n  });\n};\n```\n\n## Testing Patterns\n\n### Unit Test Structure\n\n**Service Testing:**\n```typescript\n// ✅ Good - comprehensive service testing\ndescribe('TaskService', () => {\n  let taskService: TaskService;\n  let mockTaskRepository: jest.Mocked<TaskRepository>;\n  let mockCacheService: jest.Mocked<CacheService>;\n  \n  beforeEach(() => {\n    mockTaskRepository = {\n      create: jest.fn(),\n      findById: jest.fn(),\n      findByUserId: jest.fn(),\n      update: jest.fn(),\n      delete: jest.fn()\n    };\n    \n    mockCacheService = {\n      get: jest.fn(),\n      set: jest.fn(),\n      invalidate: jest.fn()\n    };\n    \n    taskService = new TaskService(mockTaskRepository, mockCacheService);\n  });\n  \n  describe('createTask', () => {\n    it('should create task with valid data', async () => {\n      // Arrange\n      const userId = 'user-123';\n      const taskData: TaskCreateRequest = {\n        title: 'Test Task',\n        description: 'Test Description'\n      };\n      \n      const createdTask: TaskEntity = {\n        id: 'task-123',\n        userId,\n        title: taskData.title,\n        description: taskData.description,\n        status: TaskStatus.PENDING,\n        categoryId: null,\n        categoryName: null,\n        dueDate: null,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n      \n      mockTaskRepository.create.mockResolvedValue(createdTask);\n      \n      // Act\n      const result = await taskService.createTask(userId, taskData);\n      \n      // Assert\n      expect(result).toEqual(expect.objectContaining({\n        id: 'task-123',\n        title: 'Test Task',\n        description: 'Test Description',\n        status: TaskStatus.PENDING\n      }));\n      \n      expect(mockTaskRepository.create).toHaveBeenCalledWith({\n        userId,\n        title: taskData.title,\n        description: taskData.description,\n        status: TaskStatus.PENDING\n      });\n    });\n    \n    it('should throw ValidationError for empty title', async () => {\n      // Arrange\n      const userId = 'user-123';\n      const taskData: TaskCreateRequest = {\n        title: '',\n        description: 'Test Description'\n      };\n      \n      // Act & Assert\n      await expect(taskService.createTask(userId, taskData))\n        .rejects.toThrow(ValidationError);\n      \n      expect(mockTaskRepository.create).not.toHaveBeenCalled();\n    });\n  });\n});\n```\n\n### Integration Test Structure\n\n**API Testing:**\n```typescript\n// ✅ Good - comprehensive API testing\ndescribe('POST /api/tasks', () => {\n  let app: Express;\n  let authToken: string;\n  \n  beforeAll(async () => {\n    app = await createTestApp();\n    authToken = await createTestUserAndGetToken();\n  });\n  \n  afterAll(async () => {\n    await cleanupTestDatabase();\n  });\n  \n  it('should create task with valid data', async () => {\n    // Arrange\n    const taskData = {\n      title: 'Test Task',\n      description: 'Test Description',\n      dueDate: '2024-12-31T23:59:59Z'\n    };\n    \n    // Act\n    const response = await request(app)\n      .post('/api/tasks')\n      .set('Authorization', `Bearer ${authToken}`)\n      .send(taskData)\n      .expect(HttpStatus.CREATED);\n    \n    // Assert\n    expect(response.body).toMatchObject({\n      success: true,\n      data: {\n        id: expect.any(String),\n        title: 'Test Task',\n        description: 'Test Description',\n        status: 'pending',\n        dueDate: '2024-12-31T23:59:59.000Z'\n      }\n    });\n  });\n  \n  it('should return 401 without auth token', async () => {\n    // Act\n    const response = await request(app)\n      .post('/api/tasks')\n      .send({ title: 'Test Task' })\n      .expect(HttpStatus.UNAUTHORIZED);\n    \n    // Assert\n    expect(response.body).toMatchObject({\n      success: false,\n      error: {\n        code: 'AUTHENTICATION_ERROR',\n        message: 'Access token required'\n      }\n    });\n  });\n});\n```\n\n## Code Organization\n\n### File Structure\n\n```\nsrc/\n├── controllers/\n│   ├── TaskController.ts\n│   ├── UserController.ts\n│   └── AuthController.ts\n├── services/\n│   ├── TaskService.ts\n│   ├── UserService.ts\n│   └── AuthService.ts\n├── repositories/\n│   ├── TaskRepository.ts\n│   ├── UserRepository.ts\n│   └── interfaces/\n├── middleware/\n│   ├── auth.ts\n│   ├── validation.ts\n│   └── errorHandler.ts\n├── types/\n│   ├── api.ts\n│   ├── database.ts\n│   └── auth.ts\n├── utils/\n│   ├── logger.ts\n│   ├── database.ts\n│   └── validation.ts\n└── app.ts\n```\n\n### Import Organization\n\n```typescript\n// ✅ Good - organized imports\n// 1. Node.js built-in modules\nimport { promisify } from 'util';\nimport crypto from 'crypto';\n\n// 2. Third-party libraries\nimport express from 'express';\nimport jwt from 'jsonwebtoken';\nimport bcrypt from 'bcrypt';\n\n// 3. Internal modules (absolute imports)\nimport { TaskService } from '@/services/TaskService';\nimport { ValidationError } from '@/utils/errors';\n\n// 4. Relative imports\nimport { TaskCreateRequest } from './types';\nimport { validateTaskData } from './validation';\n```\n\n## Performance Guidelines\n\n### Async Patterns\n\n```typescript\n// ✅ Good - efficient async operations\nclass TaskService {\n  async getTasksWithRelatedData(userId: string): Promise<TaskWithRelatedData[]> {\n    // Parallel execution for independent operations\n    const [tasks, categories, userPreferences] = await Promise.all([\n      this.taskRepository.findByUserId(userId),\n      this.categoryRepository.findByUserId(userId),\n      this.userService.getPreferences(userId)\n    ]);\n    \n    // Process results\n    return this.enrichTasksWithRelatedData(tasks, categories, userPreferences);\n  }\n  \n  // ❌ Bad - sequential execution\n  async getTasksWithRelatedDataSlow(userId: string): Promise<TaskWithRelatedData[]> {\n    const tasks = await this.taskRepository.findByUserId(userId);\n    const categories = await this.categoryRepository.findByUserId(userId);\n    const userPreferences = await this.userService.getPreferences(userId);\n    \n    return this.enrichTasksWithRelatedData(tasks, categories, userPreferences);\n  }\n}\n```\n\n---\n\n**Document Version:** 1.0  \n**Last Updated:** 2024-01-01  \n**Style Guide Owner:** Technical Lead  \n**Next Review:** 2024-02-01