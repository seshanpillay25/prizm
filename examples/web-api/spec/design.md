# Design Document - Task Management API\n\n## Overview\n\nThe Task Management API is a RESTful web service built with Node.js and Express, providing secure, scalable task management capabilities. It follows microservices principles with clear separation of concerns and supports horizontal scaling.\n\n**Design Philosophy:** API-first design with security, performance, and developer experience as priorities  \n**Target Architecture:** Layered architecture with clear separation between presentation, business, and data layers  \n**Key Design Decisions:** JWT authentication, PostgreSQL for persistence, Redis for caching, OpenAPI documentation\n\n## Architecture\n\n### High-Level Architecture\n\n```mermaid\ngraph TB\n    A[Client Applications] --> B[Load Balancer]\n    B --> C[API Gateway]\n    C --> D[Express Application]\n    D --> E[Authentication Service]\n    D --> F[Task Service]\n    D --> G[User Service]\n    E --> H[Redis Cache]\n    F --> I[PostgreSQL Database]\n    G --> I\n    D --> J[File Storage]\n    D --> K[Monitoring Service]\n    \n    subgraph \"External Services\"\n        L[Webhook Service]\n        M[Logging Service]\n    end\n    \n    D --> L\n    D --> M\n```\n\n### System Components\n\n#### Component 1: API Gateway\n\n**Purpose:** Central entry point for all API requests  \n**Responsibilities:**\n- Request routing and load balancing\n- Rate limiting and throttling\n- CORS handling\n- Request/response logging\n- SSL termination\n\n**Interfaces:**\n- HTTP/HTTPS requests from clients\n- Internal service communication\n- Monitoring and metrics collection\n\n#### Component 2: Authentication Service\n\n**Purpose:** Handle user authentication and authorization  \n**Responsibilities:**\n- User registration and login\n- JWT token generation and validation\n- Session management\n- Password hashing and validation\n- Rate limiting for auth endpoints\n\n**Interfaces:**\n- REST endpoints for auth operations\n- JWT middleware for protected routes\n- Redis for session storage\n\n#### Component 3: Task Service\n\n**Purpose:** Core business logic for task management  \n**Responsibilities:**\n- Task CRUD operations\n- Task filtering and sorting\n- Category and tag management\n- Due date and reminder handling\n- Business rule enforcement\n\n**Interfaces:**\n- REST endpoints for task operations\n- Database operations\n- Webhook notifications\n\n#### Component 4: Data Layer\n\n**Purpose:** Data persistence and caching  \n**Responsibilities:**\n- Database connection management\n- Query optimization\n- Data validation\n- Backup and recovery\n- Cache management\n\n**Interfaces:**\n- PostgreSQL database operations\n- Redis cache operations\n- Connection pooling\n\n### Technology Stack\n\n- **Runtime:** Node.js 18+\n- **Framework:** Express.js 4.x\n- **Database:** PostgreSQL 14+\n- **Cache:** Redis 7+\n- **Authentication:** JWT with jsonwebtoken\n- **Validation:** Joi for request validation\n- **Documentation:** OpenAPI 3.0 with Swagger UI\n- **Testing:** Jest with Supertest\n- **Monitoring:** Prometheus with Grafana\n- **Logging:** Winston with ELK stack\n\n## Core Principles\n\n1. **API-First Design:** OpenAPI specification drives development\n2. **Security by Design:** Authentication and authorization built-in\n3. **Scalability:** Stateless design supporting horizontal scaling\n4. **Developer Experience:** Clear documentation and consistent error handling\n5. **Observability:** Comprehensive logging and monitoring\n\n## Data Design\n\n### Database Schema\n\n#### Users Table\n\n```sql\nCREATE TABLE users (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) UNIQUE NOT NULL,\n    password_hash VARCHAR(255) NOT NULL,\n    first_name VARCHAR(100) NOT NULL,\n    last_name VARCHAR(100) NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    deleted_at TIMESTAMP WITH TIME ZONE,\n    is_active BOOLEAN DEFAULT true\n);\n\nCREATE INDEX idx_users_email ON users(email);\nCREATE INDEX idx_users_active ON users(is_active);\n```\n\n#### Tasks Table\n\n```sql\nCREATE TABLE tasks (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES users(id),\n    title VARCHAR(200) NOT NULL,\n    description TEXT,\n    status VARCHAR(20) DEFAULT 'pending',\n    category_id UUID REFERENCES categories(id),\n    due_date TIMESTAMP WITH TIME ZONE,\n    completed_at TIMESTAMP WITH TIME ZONE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    deleted_at TIMESTAMP WITH TIME ZONE\n);\n\nCREATE INDEX idx_tasks_user_id ON tasks(user_id);\nCREATE INDEX idx_tasks_status ON tasks(status);\nCREATE INDEX idx_tasks_due_date ON tasks(due_date);\nCREATE INDEX idx_tasks_created_at ON tasks(created_at);\n```\n\n#### Categories Table\n\n```sql\nCREATE TABLE categories (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES users(id),\n    name VARCHAR(100) NOT NULL,\n    color VARCHAR(7) DEFAULT '#3498db',\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(user_id, name)\n);\n\nCREATE INDEX idx_categories_user_id ON categories(user_id);\n```\n\n#### Tags Table\n\n```sql\nCREATE TABLE tags (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES users(id),\n    name VARCHAR(50) NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(user_id, name)\n);\n\nCREATE TABLE task_tags (\n    task_id UUID NOT NULL REFERENCES tasks(id) ON DELETE CASCADE,\n    tag_id UUID NOT NULL REFERENCES tags(id) ON DELETE CASCADE,\n    PRIMARY KEY (task_id, tag_id)\n);\n```\n\n### Data Models\n\n#### User Model\n\n```javascript\nconst userSchema = {\n  id: Joi.string().uuid().required(),\n  email: Joi.string().email().required(),\n  firstName: Joi.string().min(1).max(100).required(),\n  lastName: Joi.string().min(1).max(100).required(),\n  password: Joi.string().min(8).required().strip(),\n  isActive: Joi.boolean().default(true),\n  createdAt: Joi.date().iso(),\n  updatedAt: Joi.date().iso()\n};\n```\n\n#### Task Model\n\n```javascript\nconst taskSchema = {\n  id: Joi.string().uuid().required(),\n  userId: Joi.string().uuid().required(),\n  title: Joi.string().min(1).max(200).required(),\n  description: Joi.string().max(2000).allow(''),\n  status: Joi.string().valid('pending', 'in-progress', 'completed').default('pending'),\n  categoryId: Joi.string().uuid().allow(null),\n  dueDate: Joi.date().iso().allow(null),\n  completedAt: Joi.date().iso().allow(null),\n  tags: Joi.array().items(Joi.string().max(50)),\n  createdAt: Joi.date().iso(),\n  updatedAt: Joi.date().iso()\n};\n```\n\n## API Design\n\n### Authentication Endpoints\n\n#### POST /auth/register\n\n**Purpose:** Register a new user account\n\n**Request:**\n```json\n{\n  \"email\": \"user@example.com\",\n  \"password\": \"SecurePass123!\",\n  \"firstName\": \"John\",\n  \"lastName\": \"Doe\"\n}\n```\n\n**Response (201 Created):**\n```json\n{\n  \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n  \"email\": \"user@example.com\",\n  \"firstName\": \"John\",\n  \"lastName\": \"Doe\",\n  \"createdAt\": \"2024-01-01T00:00:00Z\"\n}\n```\n\n#### POST /auth/login\n\n**Purpose:** Authenticate user and return JWT token\n\n**Request:**\n```json\n{\n  \"email\": \"user@example.com\",\n  \"password\": \"SecurePass123!\"\n}\n```\n\n**Response (200 OK):**\n```json\n{\n  \"token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...\",\n  \"expiresIn\": 86400,\n  \"user\": {\n    \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n    \"email\": \"user@example.com\",\n    \"firstName\": \"John\",\n    \"lastName\": \"Doe\"\n  }\n}\n```\n\n### Task Management Endpoints\n\n#### GET /tasks\n\n**Purpose:** Retrieve tasks with filtering and pagination\n\n**Query Parameters:**\n- `status`: Filter by task status\n- `category`: Filter by category ID\n- `tags`: Filter by tag names (comma-separated)\n- `search`: Search in title and description\n- `sort`: Sort field (title, created_at, due_date)\n- `order`: Sort order (asc, desc)\n- `page`: Page number (default: 1)\n- `limit`: Items per page (default: 20, max: 100)\n\n**Response (200 OK):**\n```json\n{\n  \"tasks\": [\n    {\n      \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n      \"title\": \"Complete project documentation\",\n      \"description\": \"Write comprehensive API documentation\",\n      \"status\": \"pending\",\n      \"categoryId\": \"456e7890-e89b-12d3-a456-426614174000\",\n      \"dueDate\": \"2024-01-15T09:00:00Z\",\n      \"tags\": [\"urgent\", \"documentation\"],\n      \"createdAt\": \"2024-01-01T00:00:00Z\",\n      \"updatedAt\": \"2024-01-01T00:00:00Z\"\n    }\n  ],\n  \"pagination\": {\n    \"page\": 1,\n    \"limit\": 20,\n    \"total\": 1,\n    \"totalPages\": 1\n  }\n}\n```\n\n#### POST /tasks\n\n**Purpose:** Create a new task\n\n**Request:**\n```json\n{\n  \"title\": \"Complete project documentation\",\n  \"description\": \"Write comprehensive API documentation\",\n  \"categoryId\": \"456e7890-e89b-12d3-a456-426614174000\",\n  \"dueDate\": \"2024-01-15T09:00:00Z\",\n  \"tags\": [\"urgent\", \"documentation\"]\n}\n```\n\n**Response (201 Created):**\n```json\n{\n  \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n  \"title\": \"Complete project documentation\",\n  \"description\": \"Write comprehensive API documentation\",\n  \"status\": \"pending\",\n  \"categoryId\": \"456e7890-e89b-12d3-a456-426614174000\",\n  \"dueDate\": \"2024-01-15T09:00:00Z\",\n  \"tags\": [\"urgent\", \"documentation\"],\n  \"createdAt\": \"2024-01-01T00:00:00Z\",\n  \"updatedAt\": \"2024-01-01T00:00:00Z\"\n}\n```\n\n#### PUT /tasks/:id\n\n**Purpose:** Update an existing task\n\n**Request:**\n```json\n{\n  \"title\": \"Updated task title\",\n  \"status\": \"in-progress\",\n  \"dueDate\": \"2024-01-16T09:00:00Z\"\n}\n```\n\n**Response (200 OK):**\n```json\n{\n  \"id\": \"123e4567-e89b-12d3-a456-426614174000\",\n  \"title\": \"Updated task title\",\n  \"description\": \"Write comprehensive API documentation\",\n  \"status\": \"in-progress\",\n  \"categoryId\": \"456e7890-e89b-12d3-a456-426614174000\",\n  \"dueDate\": \"2024-01-16T09:00:00Z\",\n  \"tags\": [\"urgent\", \"documentation\"],\n  \"createdAt\": \"2024-01-01T00:00:00Z\",\n  \"updatedAt\": \"2024-01-02T00:00:00Z\"\n}\n```\n\n## Security Design\n\n### Authentication Strategy\n\n**JWT Implementation:**\n```javascript\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\n\nclass AuthService {\n  constructor() {\n    this.privateKey = fs.readFileSync('private.key');\n    this.publicKey = fs.readFileSync('public.key');\n  }\n  \n  generateToken(user) {\n    const payload = {\n      userId: user.id,\n      email: user.email,\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + (24 * 60 * 60) // 24 hours\n    };\n    \n    return jwt.sign(payload, this.privateKey, { algorithm: 'RS256' });\n  }\n  \n  verifyToken(token) {\n    try {\n      return jwt.verify(token, this.publicKey, { algorithms: ['RS256'] });\n    } catch (error) {\n      throw new Error('Invalid token');\n    }\n  }\n}\n```\n\n**Authentication Middleware:**\n```javascript\nconst authenticate = async (req, res, next) => {\n  try {\n    const authHeader = req.header('Authorization');\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      return res.status(401).json({ error: 'Access token required' });\n    }\n    \n    const token = authHeader.substring(7);\n    const decoded = authService.verifyToken(token);\n    \n    const user = await userService.findById(decoded.userId);\n    if (!user || !user.isActive) {\n      return res.status(401).json({ error: 'Invalid user' });\n    }\n    \n    req.user = user;\n    next();\n  } catch (error) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n};\n```\n\n### Input Validation\n\n**Request Validation Middleware:**\n```javascript\nconst validateRequest = (schema) => {\n  return (req, res, next) => {\n    const { error, value } = schema.validate(req.body, {\n      abortEarly: false,\n      stripUnknown: true\n    });\n    \n    if (error) {\n      const errors = error.details.map(detail => ({\n        field: detail.path.join('.'),\n        message: detail.message\n      }));\n      \n      return res.status(400).json({\n        error: 'Validation failed',\n        details: errors\n      });\n    }\n    \n    req.validatedData = value;\n    next();\n  };\n};\n```\n\n### Rate Limiting\n\n**Rate Limiting Configuration:**\n```javascript\nconst rateLimit = require('express-rate-limit');\nconst RedisStore = require('rate-limit-redis');\n\nconst createRateLimiter = (windowMs, max, message) => {\n  return rateLimit({\n    store: new RedisStore({\n      client: redisClient,\n      prefix: 'rate_limit:'\n    }),\n    windowMs,\n    max,\n    message: { error: message },\n    standardHeaders: true,\n    legacyHeaders: false\n  });\n};\n\n// Different limits for different endpoints\nconst authLimiter = createRateLimiter(\n  15 * 60 * 1000, // 15 minutes\n  5, // 5 attempts\n  'Too many authentication attempts'\n);\n\nconst apiLimiter = createRateLimiter(\n  60 * 1000, // 1 minute\n  100, // 100 requests\n  'Too many API requests'\n);\n```\n\n## Error Handling\n\n### Error Response Format\n\n```javascript\nclass APIError extends Error {\n  constructor(message, statusCode = 500, code = 'INTERNAL_ERROR') {\n    super(message);\n    this.statusCode = statusCode;\n    this.code = code;\n    this.isOperational = true;\n  }\n}\n\nclass ValidationError extends APIError {\n  constructor(message, details = []) {\n    super(message, 400, 'VALIDATION_ERROR');\n    this.details = details;\n  }\n}\n\nclass NotFoundError extends APIError {\n  constructor(resource = 'Resource') {\n    super(`${resource} not found`, 404, 'NOT_FOUND');\n  }\n}\n\nclass ForbiddenError extends APIError {\n  constructor(message = 'Access denied') {\n    super(message, 403, 'FORBIDDEN');\n  }\n}\n```\n\n**Error Handling Middleware:**\n```javascript\nconst errorHandler = (err, req, res, next) => {\n  // Log error\n  logger.error(err.message, {\n    error: err,\n    request: {\n      method: req.method,\n      url: req.url,\n      headers: req.headers,\n      body: req.body\n    }\n  });\n  \n  // Operational errors\n  if (err.isOperational) {\n    return res.status(err.statusCode).json({\n      error: err.message,\n      code: err.code,\n      details: err.details || undefined\n    });\n  }\n  \n  // Programming errors\n  res.status(500).json({\n    error: 'Internal server error',\n    code: 'INTERNAL_ERROR'\n  });\n};\n```\n\n## Performance Optimization\n\n### Database Optimization\n\n**Query Optimization:**\n```javascript\nclass TaskRepository {\n  async findTasks(userId, filters = {}) {\n    let query = `\n      SELECT t.*, c.name as category_name,\n             array_agg(tag.name) as tags\n      FROM tasks t\n      LEFT JOIN categories c ON t.category_id = c.id\n      LEFT JOIN task_tags tt ON t.id = tt.task_id\n      LEFT JOIN tags tag ON tt.tag_id = tag.id\n      WHERE t.user_id = $1 AND t.deleted_at IS NULL\n    `;\n    \n    const params = [userId];\n    let paramIndex = 2;\n    \n    // Add filters\n    if (filters.status) {\n      query += ` AND t.status = $${paramIndex++}`;\n      params.push(filters.status);\n    }\n    \n    if (filters.categoryId) {\n      query += ` AND t.category_id = $${paramIndex++}`;\n      params.push(filters.categoryId);\n    }\n    \n    if (filters.search) {\n      query += ` AND (t.title ILIKE $${paramIndex++} OR t.description ILIKE $${paramIndex++})`;\n      params.push(`%${filters.search}%`, `%${filters.search}%`);\n    }\n    \n    query += ` GROUP BY t.id, c.name`;\n    \n    // Add sorting\n    const sortField = filters.sort || 'created_at';\n    const sortOrder = filters.order === 'asc' ? 'ASC' : 'DESC';\n    query += ` ORDER BY t.${sortField} ${sortOrder}`;\n    \n    // Add pagination\n    const limit = Math.min(filters.limit || 20, 100);\n    const offset = ((filters.page || 1) - 1) * limit;\n    query += ` LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;\n    params.push(limit, offset);\n    \n    const result = await db.query(query, params);\n    return result.rows;\n  }\n}\n```\n\n### Caching Strategy\n\n**Redis Caching:**\n```javascript\nclass CacheService {\n  constructor(redisClient) {\n    this.redis = redisClient;\n  }\n  \n  async get(key) {\n    try {\n      const value = await this.redis.get(key);\n      return value ? JSON.parse(value) : null;\n    } catch (error) {\n      logger.error('Cache get error:', error);\n      return null;\n    }\n  }\n  \n  async set(key, value, ttl = 3600) {\n    try {\n      await this.redis.setex(key, ttl, JSON.stringify(value));\n    } catch (error) {\n      logger.error('Cache set error:', error);\n    }\n  }\n  \n  async invalidatePattern(pattern) {\n    try {\n      const keys = await this.redis.keys(pattern);\n      if (keys.length > 0) {\n        await this.redis.del(...keys);\n      }\n    } catch (error) {\n      logger.error('Cache invalidation error:', error);\n    }\n  }\n}\n\n// Usage in service layer\nclass TaskService {\n  async getTasks(userId, filters = {}) {\n    const cacheKey = `tasks:${userId}:${JSON.stringify(filters)}`;\n    \n    // Try cache first\n    let tasks = await cacheService.get(cacheKey);\n    \n    if (!tasks) {\n      // Fetch from database\n      tasks = await taskRepository.findTasks(userId, filters);\n      \n      // Cache for 5 minutes\n      await cacheService.set(cacheKey, tasks, 300);\n    }\n    \n    return tasks;\n  }\n  \n  async updateTask(taskId, updates) {\n    const task = await taskRepository.updateTask(taskId, updates);\n    \n    // Invalidate related caches\n    await cacheService.invalidatePattern(`tasks:${task.userId}:*`);\n    \n    return task;\n  }\n}\n```\n\n## Testing Strategy\n\n### Unit Testing\n\n**Service Layer Tests:**\n```javascript\ndescribe('TaskService', () => {\n  let taskService;\n  let mockTaskRepository;\n  let mockCacheService;\n  \n  beforeEach(() => {\n    mockTaskRepository = {\n      findTasks: jest.fn(),\n      createTask: jest.fn(),\n      updateTask: jest.fn(),\n      deleteTask: jest.fn()\n    };\n    \n    mockCacheService = {\n      get: jest.fn(),\n      set: jest.fn(),\n      invalidatePattern: jest.fn()\n    };\n    \n    taskService = new TaskService(mockTaskRepository, mockCacheService);\n  });\n  \n  describe('getTasks', () => {\n    it('should return cached tasks if available', async () => {\n      const cachedTasks = [{ id: '1', title: 'Test Task' }];\n      mockCacheService.get.mockResolvedValue(cachedTasks);\n      \n      const result = await taskService.getTasks('user-id');\n      \n      expect(result).toEqual(cachedTasks);\n      expect(mockTaskRepository.findTasks).not.toHaveBeenCalled();\n    });\n    \n    it('should fetch from database if not cached', async () => {\n      const dbTasks = [{ id: '1', title: 'Test Task' }];\n      mockCacheService.get.mockResolvedValue(null);\n      mockTaskRepository.findTasks.mockResolvedValue(dbTasks);\n      \n      const result = await taskService.getTasks('user-id');\n      \n      expect(result).toEqual(dbTasks);\n      expect(mockTaskRepository.findTasks).toHaveBeenCalledWith('user-id', {});\n      expect(mockCacheService.set).toHaveBeenCalled();\n    });\n  });\n});\n```\n\n### Integration Testing\n\n**API Endpoint Tests:**\n```javascript\ndescribe('POST /tasks', () => {\n  let authToken;\n  \n  beforeEach(async () => {\n    // Create test user and get auth token\n    const user = await testUtils.createUser();\n    authToken = await testUtils.getAuthToken(user);\n  });\n  \n  it('should create task with valid data', async () => {\n    const taskData = {\n      title: 'Test Task',\n      description: 'Test Description',\n      dueDate: '2024-01-15T09:00:00Z'\n    };\n    \n    const response = await request(app)\n      .post('/tasks')\n      .set('Authorization', `Bearer ${authToken}`)\n      .send(taskData)\n      .expect(201);\n    \n    expect(response.body).toMatchObject({\n      id: expect.any(String),\n      title: 'Test Task',\n      description: 'Test Description',\n      status: 'pending',\n      dueDate: '2024-01-15T09:00:00.000Z'\n    });\n  });\n  \n  it('should return 400 for invalid data', async () => {\n    const response = await request(app)\n      .post('/tasks')\n      .set('Authorization', `Bearer ${authToken}`)\n      .send({ title: '' }) // Empty title\n      .expect(400);\n    \n    expect(response.body).toMatchObject({\n      error: 'Validation failed',\n      details: expect.arrayContaining([\n        expect.objectContaining({\n          field: 'title',\n          message: expect.stringContaining('required')\n        })\n      ])\n    });\n  });\n});\n```\n\n## Deployment Architecture\n\n### Container Configuration\n\n**Dockerfile:**\n```dockerfile\nFROM node:18-alpine\n\n# Create app directory\nWORKDIR /app\n\n# Install dependencies\nCOPY package*.json ./\nRUN npm ci --only=production\n\n# Copy source code\nCOPY . .\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs\nRUN adduser -S nextjs -u 1001\nUSER nextjs\n\n# Expose port\nEXPOSE 3000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:3000/health || exit 1\n\n# Start application\nCMD [\"npm\", \"start\"]\n```\n\n**Docker Compose:**\n```yaml\nversion: '3.8'\n\nservices:\n  api:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - DATABASE_URL=postgresql://postgres:password@db:5432/taskdb\n      - REDIS_URL=redis://redis:6379\n      - JWT_PRIVATE_KEY_PATH=/app/keys/private.key\n      - JWT_PUBLIC_KEY_PATH=/app/keys/public.key\n    depends_on:\n      - db\n      - redis\n    volumes:\n      - ./keys:/app/keys:ro\n  \n  db:\n    image: postgres:14\n    environment:\n      - POSTGRES_DB=taskdb\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=password\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n  \n  redis:\n    image: redis:7-alpine\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis_data:/data\n\nvolumes:\n  postgres_data:\n  redis_data:\n```\n\n---\n\n**Document Version:** 1.0  \n**Last Updated:** 2024-01-01  \n**Next Review:** 2024-02-01  \n**Approved By:** Technical Lead